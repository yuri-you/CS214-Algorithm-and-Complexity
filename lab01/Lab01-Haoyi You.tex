\documentclass[12pt,a4paper]{article}
\usepackage{amsmath,amscd,amsbsy,amssymb,latexsym,url,bm,amsthm}
\usepackage{epsfig,graphicx,subfigure}
\usepackage{enumitem,balance}
\usepackage{wrapfig}
\usepackage{mathrsfs,euscript}
\usepackage[usenames]{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage[vlined,ruled,linesnumbered]{algorithm2e}
\usepackage{threeparttable}
\hypersetup{colorlinks=true,linkcolor=black}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{exercise}{Exercise}
\newtheorem*{solution}{Solution}
\newtheorem{definition}{Definition}
\theoremstyle{definition}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\postscript}[2]
 {\setlength{\epsfxsize}{#2\hsize}
  \centerline{\epsfbox{#1}}}

\renewcommand{\baselinestretch}{1.0}

\setlength{\oddsidemargin}{-0.365in}
\setlength{\evensidemargin}{-0.365in}
\setlength{\topmargin}{-0.3in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{10.1in}
\setlength{\textwidth}{7in}
\makeatletter \renewenvironment{proof}[1][Proof] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother
\makeatletter
\renewenvironment{solution}[1][Solution] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother

\begin{document}
\noindent

%========================================================================
\noindent\framebox[\linewidth]{\shortstack[c]{
\Large{\textbf{Lab01-Algorithm Analysis}}\vspace{1mm}\\
CS214-Algorithm and Complexity, Xiaofeng Gao, Spring 2021.}}
\begin{center}


% Please write down your name, student id and email.
\footnotesize{\color{blue}$*$ Name:\underline{\quad   Haoyi You  \quad  }\quad Student ID:\underline{\quad 519030910193 \quad} \quad Email: \underline{\quad yuri-you@sjtu.edu.cn \quad}}
\end{center}

\begin{enumerate}


\item \textit{Complexity Analysis.} Please analyze the time and space complexity of Alg.~\ref{Alg-quicksort} and Alg.~\ref{Alg-cocktailsort}. \par

\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
		\KwIn{An array $A[1,\cdots,n]$}
		\KwOut{$A[1,\cdots,n]$ sorted nondecreasingly}
		
		\BlankLine
		\caption{QuickSort}\label{Alg-quicksort}
		
		%\If{$n \le 1$}{
		%  \Return\;
		%}
		
		$pivot \leftarrow A[n]$; $i \leftarrow 1$\;
		\For{$j \leftarrow 1$ \KwTo $n-1$}{
			\If{$A[j] < pivot$}{
				swap $A[i]$ and $A[j]$\;
				$i \leftarrow i+1$\;
			}
		}
		
		swap $A[i]$ and $A[n]$\;
		\lIf{$i>1$}{$\operatorname{QuickSort}(A[1,\cdots,i-1])$}
		\lIf{$i<n$}{$\operatorname{QuickSort}(A[i+1,\cdots,n])$}
	\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\begin{algorithm}[H]
\KwIn{An array $A[1,\cdots,n]$}
\KwOut{$A[1,\cdots,n]$ sorted nonincreasingly}
\BlankLine
\caption{CocktailSort}
\label{Alg-cocktailsort}
\BlankLine
	$i\leftarrow 1;$ $j\leftarrow n;$$sorted\leftarrow false$\;
	\While{\textbf{not} sorted}{
		$sorted \leftarrow true$\;
		\For{$k\leftarrow i$ \textbf{to} $j-1$}{
			\If{$A[k] < A[k+1]$}{
				swap $A[k]$ and $A[k+1]$\;
				$sorted\leftarrow false$\;
			}
		}
		$j\leftarrow j-1$\;
		

		\For{$k\leftarrow j$ \textbf{downto} $i+1$}{
			\If{$A[k-1] < A[k]$}{
				swap $A[k-1]$ and $A[k]$\;
				$sorted\leftarrow false$\;
			}
		}
		$i\leftarrow i+1$\;
	}
\end{algorithm}
\end{minipage}

\begin{enumerate}
	 
\item Fill in the blanks and \textbf{explain} your answers. You need to answer when the best case and the worst case happen. 
\begin{table}[!h]

\label{Tab-compare}
	\centering
	\begin{threeparttable}
	\begin{tabular}{c|c| c }
		\toprule[2pt]
		\textbf{Algorithm} & \textbf{Time Complexity}\tnote{1} & \textbf{Space Complexity} \\
		\hline
		\hline
		$QuickSort$ & $ \Omega (nlog(n))\quad O(nlog(n))\quad O(n^2) $&$O(log(n))$(worst case $O(n)$)  \\

		$CocktailSort$ & $\Omega (n)\quad O(n^2)\quad O(n^2)$ &$O(1)$   \\
		\bottomrule[2pt]


	\end{tabular}
    \begin{tablenotes}
    	\footnotesize
    	\item[1] The response order can be given in \emph{best}, \emph{average}, and \emph{worst}.
    \end{tablenotes}
	\end{threeparttable}
\end{table}

\item For Alg.~\ref{Alg-quicksort}, how to modify the algorithm to achieve the same expected performance as the \textbf{average} case when the \textbf{worst} case happens?
\end{enumerate} 




    \begin{solution}
    \item (a):
    
    QuickSort:\\
    1)Time Complexity\\
    Best case: $\Omega (nlog(n))$.\par
    The best case happens when $A[n]$ is the ${\lceil\frac{n}{2}\rceil}^{th}$ largest number in the array.Then when the program enters and exits the loop,it at least needs $2*(n-1)$ operations.Adding assignment operation before loop and swap operations after loop,there are at least $2n$ operations. So one recursion costs 2 times length of the array. The length of next recursion is half of this time's. So the total amount of comparison will be $2n+\lceil\frac{2n}{2}\rceil+\lceil\frac{\lceil\frac{2n}{2}\rceil}{2}\rceil...=\Omega (nlog(n))$ 
    
    Average case: $O(nlog(n))$.\par
    Assume the expectation of numbers of operations of n-length array in quicksort is $f(n)$.
    From the best case we know in one recursion cost $2n$ operations. So we know 
    \begin{equation}
    \begin{aligned}
        f(n)&=2n+E[next~recursions]\\&=2n+(\sum_{i=0}^{n-1}\frac{f(i)+f(n-1-i)}{2})/n\\&=2n+(\sum_{i=0}^{n-1}f(i))/n.
        \end{aligned}
        \label{you1}
    \end{equation}
    And $f(0)=0$,from the equation \ref{you1},we can solve the result $f(n)=O(nlog(n))$ by induction.If $f(k)=O(klog(k))$, assume $d*(klog(k))\leq f(k)\leq c*(klog(k))$  for $k\leq n-1$,and $n\geq 10$
    
    \begin{equation}
    \begin{aligned}
        &(\sum_{i=0}^{n-1}f(i))/n\leq(\sum_{i=0}^{n-1}c*i*log(i))/n\leq(\sum_{i=0}^{n-1}c*i*log(n))/n\leq c*(\frac{n}{2}log(n)) \\
        \Rightarrow &f(n)=2n+(\sum_{i=0}^{n-1}f(i))/n\leq 2n+c*(\frac{n}{2}log(n))\leq c*\frac{n}{2}log(n)+c*(\frac{n}{2}log(n))\\&=c*nlog(n)
    \end{aligned}
    \label{you2}
    \end{equation}.
    And we know $(nln(n))^{(2)}=\frac{1}{n}>0$,so 
    \begin{equation}
    \begin{aligned}
        &i*log(i)+(n-i)log(n-i)\geq 2*(\frac{n}{2})log(\frac{n}{2})\\
        \Rightarrow&(\sum_{i=0}^{n-1}f(i))/n)\geq \frac{n}{2}log(\frac{n}{2})
        \\
        \Rightarrow&f(n)=2n+(\sum_{i=0}^{n-1}f(i))/n)\geq 2n+d*(\frac{n}{2}log(\frac{n}{2}))\geq d*nlog(n)
        % (\sum_{i=0}^{n-1}f(i))/n=(\sum_{i=0}^{\lfloor\frac{n}{2}\rfloor}ilog(i))/n+(\sum_{i=\lfloor\frac{n}{2}\rfloor+1}^{n-1}ilog(i))/n\geq (\sum_{i=\frac{n}{2}+1}^{n-1}ilog(i))/n\geq (\sum_{i=\frac{n}{2}+1}^{n-1}ilog(n/2))/n=
        % \\\frac{(3n+2)}{8}*log(n/2)
    \end{aligned}
    \label{you3}
    \end{equation}
    So from equation \ref{you2},\ref{you3},as long as we choose suitable $c$ and $d$,there are $O(nlog(n))\leq O(nlog(n))\leq O(nlog(n))$.Therefore, $f(n)=O(nlog(n))$
    
    Worst case: $O(n^2)$. \par
    The worst case happens when the array is ordered from $1$ to $n$.Then for the proof above,in each recursion,it cost 2n operations,and then the next will have n-1 elements.The total amount of operations will be $\sum_{i=1}^{n}2n=n*(n+1)=O(n^2)$\\
    \\
    2) Space Complexity:\\
    It only use 3 values  $i,j,pivot$ in one recursion.However,the depth of recursion is $log n$ in average and best case, and $n$ in worst case.So the space comlexity is $O(log n)$ in average and best case,and $O(n)$ in worst case.
    \\
    \\CocktailSort:
    \\1)Time Complexity:
    \\Best case:$\Omega (n)$
    \\The best case happens when the array is already sorted. Then it only need to enter the loop once and scan the whole array twice(from 1 to n-1 and from n-1 to 2),then the total operations are $\Omega (n)$.\\
    Average case:$O(n^2)$
    \\The time depends on the times of entering the loop, and the $k^{th}$ time entering the loop cost about $2(n+2-2k)-1$ operations.Assume the expectation of numbers of operations are $f(n)$.
    \\Firstly,it at most enters the loop for $\lceil \frac{n}{2}\rceil$ times, because this time $i\le j$ .As a result,\\$f(n)\le \frac{(n+1)*n}{2}=O(n^2)$
    \\Meanwhile,let the $g(n)=\sum_{i=1}^{n}|A[i]-i|$ .So it is obviously that $g(n)\leq f(n)*2$,for after one swap $g(n)$ at most minus 2.
    \\As for $g(n)$,assume there is an array of $n-1$ elements in a random
    order.We extend this array to $n$ elements by appending the element $n$ at the end of the previous array.Then we random sway the element $n$ and a random element from $1$ to $n$(we can sway $n$ with itself).After that,the new array of $n$ is still in a random order.
    If we choose the element in first $n-1$ place,the possibility is $\frac{n-1}{n}$. Assume we choose the element $i$ in $j^{th}$ place.
    So we have the recurrence formula below.
    
    \begin{equation}
    \begin{aligned}
        g(n)&=g(n-1)+\frac{n-1}{n}*\frac{1}{(n-1)^2}*(\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}n-i+n-j-|i-j|)
        \\&=g(n-1)+\frac{1}{(n-1)n}*[(n-1)^2*2n-2*(n-1)*\frac{n*(n-1)}{2}-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}|i-j|)
        \\&=g(n-1)+n-1-\frac{1}{(n-1)n}*(2*\sum_{i=1}^{n-1}\frac{i*(i-1)}{2})
        \\&=g(n-1)+n-1-\frac{1}{(n-1)n}*\frac{(n-1)*n*(n-2)}{3}
        \\&=g(n-1)+\frac{2n-1}{3}
    \end{aligned}
    \label{you3}
    \end{equation}
    We have known $g(1)=0,g(2)=1,g(3)=\frac{8}{3}$ ,from the recursion formula ~\ref{you3} we can get
    \begin{equation}
        g(n)=g(1)+\sum_{i=2}^{n}\frac{2n-1}{3}=\frac{n^2-1}{3}
    \end{equation}
    \\So $f(n)\ge g(n)/2=\frac{n^2-1}{6}=O(n^2)$.And we have proved $f(n)\le O(n^2)$.\\So $f(n)=O(n^2)$
    \\Worst case:$O(n^2)$
    \\The worst case happens when the array is reverse ordered.Then we have to enter the loop for $\lceil \frac{n}{2}\rceil$ times.So the number of operations is $O(n^2)$.
        \\
    2) Space Complexity:\\
    It only use 3 values $i,j,sorted$,so it is $O(1)$\\
    \\
    (b):\\For Alg.~\ref{Alg-quicksort},the worst case originate from the situation that chosen element assigned to $pivot$ is fixed to be $A[n]$. So as long as the array is almost ordered or reverse ordered, every time the recursion can only shorten the length of the array 1 element rather than almost half of the elements.
    \\Aiming at the shortcomings of the algorithm, it should change the assignment element. Each recursion it need assign a random element to $pivot$ rather than the last element of the array. Just change the first line to 
    \begin{equation}
        pivot \leftarrow A[random(1~to~n)];i\leftarrow 1;
    \end{equation}
    \end{solution}
    
\item \textit{Growth Analysis.} Rank the following functions by order of growth with brief explanations: that is, find an arrangement $g_1, g_2, \ldots , g_{15}$ of the functions $g_1 = \Omega(g_2), g_2 = \Omega(g_3), \ldots, g_{14} = \Omega(g_{15})$.  Partition your list into equivalence classes such that functions $f(n)$ and $g(n)$ are in the same class if and only if $f(n) = \Theta(g(n))$. Use symbols ``$=$'' and ``$\prec$'' to order these functions appropriately. Here $\log n$ stands for $\ln n$.
$$
\begin{array}{ccccc}
	1 \quad & \quad n \quad & \quad \log n \quad & \quad \log (\log n) \quad & \quad n \log n \\
	\log_4 n \quad & \quad 2^n \quad & \quad 4^n \quad & \quad 2^{\log n} \quad & \quad 2^{2^n} \\
	\log (n!) \quad & \quad n! \quad & \quad (2n)! \quad & \quad  n^{1/2} \quad & \quad n^2 \\
\end{array}
$$
    \begin{solution}
       \begin{equation}
       \begin{aligned}
           1 \prec log(log~n) \prec log_4~n =log~n \prec n^{\frac{1}{2}}  \prec 2^{log~n}\prec n\\\prec log(n!)= n~log~n \prec n^2 \prec 2^n \prec 4^n \prec n! \prec (2n)! \prec 2^{2^n}
       \end{aligned}
       \end{equation}
    \end{solution}


\end{enumerate}

\vspace{20pt}

% \textbf{Remark:} You need to include your .pdf and .tex files in your uploaded .rar or .zip file.

%========================================================================
\end{document}
